# HOW TO USE POS REAL RANDOM NUMBER

This article describes how to use POS REAL random Numbers in your DApp for DApp developers.

The features of POS random Numbers are as follows:

1. Generate frequency: generate for each epoch;
2. Numerical range: 0 ~ 2^256 - 1;
3. Generation time: after about 16:00 UTC every day, the time is not fixed;
4. Characteristics: 25 random leaders CALC it by multi-party calculation based on cryptography, which is unpredictable;
5. Working code: Preset in the go-wanchain node in the way of pre-compiled contract;
6. Pre-compiled contract address: 0x262;

## METHOD OF USE

The method of use is divided into two aspects: SMART contract acquisition on the chain and acquisition from DApp page.

### 1. Obtain POS random Numbers FROM the smart contract

The developer can call the precompiled contract fetching, or use the following helper fetching contract code.

The developer can deploy the following contract code on the chain or inherit it from an existing contract to obtain the POS random Numbers using the interface in the code.

***NOTE***

1) **randomPrecompileAddr** parameter in the code, please fill in **Address (0x262)**;

2) By default, the code will get the random number generated by a previous EPOCH of epochId. To get the random number just generated by the current epoch, please set **epochId as the current epoch +1.**


```
pragma solidity 0.4.26;


contract PosHelper {

    function callWith32BytesReturnsUint256(
        address to,
        bytes32 functionSelector,
        bytes32 param1
    ) private view returns (uint256 result, bool success) {
        assembly {
            let freePtr := mload(0x40)

            mstore(freePtr, functionSelector)
            mstore(add(freePtr, 4), param1)

            // call ERC20 Token contract transfer function
            success := staticcall(gas, to, freePtr, 36, freePtr, 32)

            result := mload(freePtr)
        }
    }

    function getRandomByEpochId(uint256 epochId, address randomPrecompileAddr)
        public
        view
        returns (uint256)
    {
        bytes32 functionSelector = keccak256(
            "getRandomNumberByEpochId(uint256)"
        );

        (uint256 result, bool success) = callWith32BytesReturnsUint256(
            randomPrecompileAddr,
            functionSelector,
            bytes32(epochId)
        );

        require(success, "ASSEMBLY_CALL getRandomByEpochId failed");

        return result;
    }

    function getRandomByBlockTime(
        uint256 blockTime,
        address randomPrecompileAddr
    ) public view returns (uint256) {
        bytes32 functionSelector = keccak256(
            "getRandomNumberByTimestamp(uint256)"
        );

        (uint256 result, bool success) = callWith32BytesReturnsUint256(
            randomPrecompileAddr,
            functionSelector,
            bytes32(blockTime)
        );

        require(success, "ASSEMBLY_CALL getRandomByBlockTime failed");

        return result;
    }

    function getEpochId(uint256 blockTime, address randomPrecompileAddr)
        public
        view
        returns (uint256)
    {
        bytes32 functionSelector = keccak256("getEpochId(uint256)");

        (uint256 result, bool success) = callWith32BytesReturnsUint256(
            randomPrecompileAddr,
            functionSelector,
            bytes32(blockTime)
        );

        require(success, "ASSEMBLY_CALL getEpochId failed");

        return result;
    }
}

```

### 2. Get the random POS number from DApp page

If you need to get and use random Numbers directly from the DApp page, you can use the Jack's Pot contract that is currently deployed to get random Numbers.

Smart contract address: **0x76b074d91f546914c6765ef81cbdc6f9c7da5685**

Using the following ABI, you can use the Web3 interface or other means to directly read random on the chain.

```
[
    {
      "constant": true,
      "inputs": [
        {
          "name": "epochId",
          "type": "uint256"
        },
        {
          "name": "randomPrecompileAddr",
          "type": "address"
        }
      ],
      "name": "getRandomByEpochId",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "name": "blockTime",
          "type": "uint256"
        },
        {
          "name": "randomPrecompileAddr",
          "type": "address"
        }
      ],
      "name": "getRandomByBlockTime",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "name": "blockTime",
          "type": "uint256"
        },
        {
          "name": "randomPrecompileAddr",
          "type": "address"
        }
      ],
      "name": "getEpochId",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ]
```

For example, use Web3JS to get:

```
const Web3 = require('web3');

// You can get YOUR-API-KEY from iwan.wanchain.org
let iWanUrl = "wss://api.wanchain.org:8443/ws/v3/YOUR-API-KEY";

let web3 = new Web3(new Web3.providers.WebsocketProvider(iWanUrl));

// fill abi shown above
let abi = "YOUR-ABI";

let addr = "0x76b074d91f546914c6765ef81cbdc6f9c7da5685";

let sc = new web3.eth.Contract(abi, addr);

let epochId = await sc.methods.getEpochId().call();

let random = await sc.methods.getRandomByEpochId(epochId + 1).call();

```

If the random value obtained is 0, means the random number of the current epoch has not been generated.